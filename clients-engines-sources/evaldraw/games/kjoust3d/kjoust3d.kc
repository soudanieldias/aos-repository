   //KJoust3d by Ken Silverman (written mostly in January 2009)
   //
   //NOTES:
   //  * Net play supported, but lacks client-side prediction (i.e. LAN-only for now)
   //  * To practice flying, set AI_STUCK=1
   //  * Press 'delete' for literal easter egg :) Also, congrats on reading the doc :)
   //
   //All media generated or made by myself except:
   //  * lava2.jpg, purpmont.jpg: Generated by Tom Dobrowolski using his 'texgen' program
   //  * kensky.jpg: Made by Ken in Terragen v0.9
   //  * crow.flac: Extracted from some animal sounds website
   //  * flap.flac: Extracted from some flag waving sound effect

enum {NBOTS=99,AI_STUCK=0};
static sepoff = 0.1, pixoff = 20; //eye separation settings

struct { x,y,z; } point3d;
enum {PAKSIZ=5};
//--------------------------------------------------------------
enum {PLAYMAX=8};
struct { x,y,z,vx,vy,vz,h,v,onfloor,deathtim,score,botgoal; } play_t;

   //   //Egg equation (generated at 64^3)
   //(x,y,z,&r,&g,&b)
   //r = 128; g = 128; b = 128;
   //if (x^2 + y^2 + ((1-z)^0.71-1)^2 < .4) return(1);
enum {EGGMAX=64};
struct { x,y,z,vx,vy,vz,onfloor,owner; } egg_t;

enum {STEAMMAX=64};
struct {x,y,owner,tim; } steam_t;

enum {PPAKBUF=1024};
static ppak[PPAKBUF][PAKSIZ]; //for client-side prediction

enum {PLATMAX=32};
struct { x,y,z,xs,ys,c; } plat_t;
static platn = 8;

//--------------------------------------------------------------

static tim, movingplat, MOVINGRAD = 16.5;
static playcol[PLAYMAX], flaptim[PLAYMAX];

static crcv[PLAYMAX][64][PAKSIZ], crcn[PLAYMAX], crcpakcnt = 0, oos = 0;

()
{               //Synced vars:     Predicted vars:
   static play_t  play[PLAYMAX]  , pplay[PLAYMAX];
   static         playn  = 0     , pplayn  = 0;
   static egg_t   egg[EGGMAX]    , pegg[EGGMAX];
   static         eggn   = 0     , peggn   = 0;
   static steam_t steam[STEAMMAX], psteam[STEAMMAX];
   static         steamn = 0     , psteamn = 0;
   static         rseed  = 0     , prseed  = 0;
   static         gtim   = 0     , pgtim   = 0;
   static plat_t  plat[PLATMAX] =
   {
       -6, -6,-4,2,2,0xe0f0e0,
        6, -6,-4,2,2,0xe0f0e0,
        0,-10,-4,8,2,0xe0f0e0,
        0,  7,-7,2,2,0xe0e0e0,
        0,  0,-1,8,8,0xe0e0e0,
      -12, +2,-6,3,3,0xf0e0e0,
      +12, +2,-6,3,3,0xf0e0e0,
        0,  0, 0,0,0,0xd8c8a8,
   }                             , pplat[PLATMAX];

   static lpak[PAKSIZ];

   srand(17);

   playcol[0] = 0xffa0a0; playcol[1] = 0xa0ffa0; playcol[2] = 0xa0a0ff; playcol[3] = 0xffffff;
   playcol[4] = 0xffffa0; playcol[5] = 0xa0ffff; playcol[6] = 0xffa0ff; playcol[7] = 0x808080;
   for(i=8;i<PLAYMAX;i++) playcol[i] = 2^24*rnd;

   from = 0; val = 0;

   if (net_me >= PLAYMAX)
   {
      while (1)
      {
         cls(0);
         moveto(xres/2-16,yres/2); printf("Server full!");
         refresh();
      }
   }

   playn = min(net_players+NBOTS,PLAYMAX);
   myview = net_me;

   movingplat = platn-1;

   for(p=0;p<playn;p++)
   {
      respawn(p,p,play,&playn,plat,&rseed);
      g = int((playn-1)*rnd);
      if (g >= p) g++;
      play[p].botgoal = g;
   }

      //Copy sync to pred
   for(i=playn -1;i>=0;i--) pplay [i] = play [i]; pplayn  = playn;
   for(i=eggn  -1;i>=0;i--) pegg  [i] = egg  [i]; peggn   = eggn;
   for(i=steamn-1;i>=0;i--) psteam[i] = steam[i]; psteamn = steamn;
   for(i=platn -1;i>=0;i--) pplat [i] = plat [i];
   prseed = rseed; pgtim = gtim;

   spakn = 0; ppakn = 0; //sync/pred packet counts of own packets

   tim = klock();

   while (1)
   {
      if ((USINGSTEREO == 0) || ((numframes%2) == 0))
      {
         otim = tim; tim = klock(); dtim = max(tim-otim,1e-6);
         mx = 0; my = 0; readmouse(&mx,&my);
//----------------------------------------------------------------------------
         if ((net_me == 0) || (ppakn-spakn < PPAKBUF))
         {
            if (keystatus[0x1d] || keystatus[0x9d] ||
                keystatus[0x2a] || keystatus[0x36] || bstatus)
            {
               keystatus[0x1d] = 0; keystatus[0x9d] = 0;
               keystatus[0x2a] = 0; keystatus[0x36] = 0; bstatus = 0;
               doflap = 1;
            } else doflap = 0;

            lpak[0] = net_me; //<-this value is required for bot_ai to work
            lpak[1] = dtim; lpak[2] = mx; lpak[3] = my;
            lpak[4] = keystatus[0xcb]*1+keystatus[0xcd]*2+
                      keystatus[0xc8]*4+keystatus[0xd0]*8+doflap*16+keystatus[0xd3]*32;
            keystatus[0xd3] = 0;
            net_send(NET_ALL,lpak,PAKSIZ);

            if (net_me)
            {
               for(i=0;i<PAKSIZ;i++) { ppak[ppakn%PPAKBUF][i] = lpak[i]; } ppakn++;

               move_player(lpak,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,1);
               for(i=0;i<net_players;i++)
               {
                  if (i == net_me) continue;
                  lpak[0] = i; lpak[1] = dtim; lpak[2] = 0; lpak[3] = 0; lpak[4] = 0;
                  move_player(lpak,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,1);
               }
               dtim = 1/60; move_objects(dtim,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,1);

            }
         }

         gototh = 0;
         while (net_recv(&from,lpak,PAKSIZ))
         {
            if (lpak[0] < 0) { writecrc(from,lpak); continue; }

            if (lpak[0] == net_me) spakn++; else gototh = 1;
            move_player(lpak,play,&playn,egg,&eggn,steam,&steamn,plat,&rseed,&gtim,(net_me==0)||(net_me!=from));
            if (lpak[0] == 0) { dtim = 1/60; move_objects(dtim,play,&playn,egg,&eggn,steam,&steamn,plat,&rseed,&gtim,(net_me==0)||(net_me!=from)); }

            crcpakcnt--;
            if (crcpakcnt < 0)
            {
               crcpakcnt = 64; getcrc(lpak,play,&playn,egg,&eggn,steam,&steamn,&rseed,&gtim);
               lpak[0] = -1; net_send(NET_ALLELSE,lpak,PAKSIZ);
               writecrc(net_me,lpak);
            }
         }

         if ((gototh) && (net_me))
         {
               //Copy sync to pred
            for(i=playn -1;i>=0;i--) pplay [i] = play [i]; pplayn  = playn;
            for(i=eggn  -1;i>=0;i--) pegg  [i] = egg  [i]; peggn   = eggn;
            for(i=steamn-1;i>=0;i--) psteam[i] = steam[i]; psteamn = steamn;
            for(i=platn -1;i>=0;i--) pplat [i] = plat [i];
            prseed = rseed; pgtim = gtim;

                //recalculate: apply predicted packs on top of synced state
            for(j=spakn;j<ppakn;j++)
            {
               for(i=0;i<PAKSIZ;i++) lpak[i] = ppak[j%PPAKBUF][i];

               move_player(lpak,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,0);
               for(i=0;i<net_players;i++)
               {
                  if (i == net_me) continue;
                  lpak[0] = i; lpak[1] = dtim; lpak[2] = 0; lpak[3] = 0; lpak[4] = 0;
                  move_player(lpak,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,0);
               }
               dtim = 1/60; move_objects(dtim,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat,&prseed,&pgtim,0);
            }
         }

            //CapsLock+NumLock+ScrollLock: OOS key! For testing only!
         if (keystatus[0x3a]&&keystatus[0x45]&&keystatus[0x46])
         {
            keystatus[0x3a] = 0; keystatus[0x45] = 0; keystatus[0x46] = 0;
            playtext(",soysoysoi!");
            play[0].x += 1e-2;
         }

         if (keystatus[0x2b]) //backslash
         {
            keystatus[0x2b] = 0;
            myview = (myview+1)%playn;
         }
         for(i=0;i<min(playn,10);i++) if (keystatus[i+0x2]) myview = i;
      }
//--------------------------- Drawing code goes below ---------------------------
      if (net_me == 0) drawit(myview, play, &playn, egg, &eggn, steam, &steamn, plat);
                  else drawit(myview,pplay,&pplayn,pegg,&peggn,psteam,&psteamn,pplat);

      refresh();
      Sleep((numframes/60-klock())*1000); //Limit fps smart way (lower CPU usage)
      //while (klock()<numframes/60); //Limit fps stupid way (CPU=100%)
   }
}
//-------------------------------------------------------------------------------------------------
krnd (&kholdrand) //unsynced rnd (for drawing&AI)!
{
   kholdrand = ((kholdrand*214013)+2531011*2)%(2^32);
   return(kholdrand/2^32);
}

respawn (p,sugg,play_t play[PLAYMAX],&playn,plat_t plat[PLATMAX],&rseed)
{
   enum {RN=9};
   struct { x,y,z,h; } respawn_t;
   static respawn_t respawn[RN] =
   {
      +0.0,+6.0,-7.51,-1.5708,
      -6.0,-6.0,-4.51,+1.2000,
      +6.0,-6.0,-4.51,+1.8000,
      +0.0,-9.5,-4.51,+1.5708,
     -12.0,+2.0,-6.51,+0.0000,
     +12.0,+2.0,-6.51,+3.1416,
      -1.5,+7.0,-1.51,-1.5708,
      +1.5,+7.0,-1.51,-1.5708,
   };

   respawn[RN-1].x = plat[movingplat].x;
   respawn[RN-1].y = plat[movingplat].y;
   respawn[RN-1].z = -3.51;
   respawn[RN-1].h = atan2(respawn[RN-1].y,respawn[RN-1].x)+PI;

   if (sugg < 0)
   {
      if (playn < 2)
         sugg = int(RN*krnd(&rseed));
      else
      {
         dmax = 0; sugg = 0;
         for(r=RN-1;r>=0;r--)
         {
            dmin = 1e32;
            for(q=0;q<playn;q++)
            {
               if (p == q) continue;
               d = (play[q].x-respawn[r].x)^2 +
                   (play[q].y-respawn[r].y)^2 +
                   (play[q].z-respawn[r].z)^2;
               if (d < dmin) dmin = d;
            }
            if (dmin > dmax) { dmax = dmin; sugg = r; }
         }
      }
   }
   play[p].x = respawn[sugg].x;
   play[p].y = respawn[sugg].y;
   play[p].z = respawn[sugg].z;
   play[p].h = respawn[sugg].h;
   play[p].vx = 0; play[p].vy = 0; play[p].vz = 0;
   play[p].v = .2;
   play[p].onfloor = 1;
   play[p].deathtim = 0;
   flaptim[p] = -1;
}

spawnegg (p,q,play_t play[PLAYMAX],&playn,egg_t egg[EGGMAX],&eggn,&rseed)
{
   if (eggn >= EGGMAX) return;
   egg[eggn].x = play[p].x;
   egg[eggn].y = play[p].y;
   egg[eggn].z = play[p].z;
   if (q == p)
   {
      egg[eggn].x -= cos(play[p].h)*.8;
      egg[eggn].y -= sin(play[p].h)*.8;
      egg[eggn].vx = play[p].vx+cos(play[p].h)*-.1;
      egg[eggn].vy = play[p].vy+sin(play[p].h)*-.1;
      egg[eggn].vz = play[p].vz;
   }
   else
   {
      dx = play[q].x-play[p].x; dy = play[q].y-play[p].y;
      f = sqrt(dx^2 + dy^2);
      egg[eggn].vx = play[p].vx;
      egg[eggn].vy = play[p].vy;
      if (f > .01)
      {
         f = -.2/f;
         egg[eggn].vx += dx*f;
         egg[eggn].vy += dy*f;
      }
      else
      {
         egg[eggn].vx += (krnd(&rseed)-.5)*.1;
         egg[eggn].vy += (krnd(&rseed)-.5)*.1;
      }
      egg[eggn].vz = (krnd(&rseed)-.5)*.05-.2;
   }
   egg[eggn].onfloor = 0;
   egg[eggn].owner = p;
   eggn++;
}

dist2plat2 (px,py,pz,x,y,z,hx,hy)
{
   hz = .2;
   xx = min(max(px,x-hx),x+hx);
   yy = min(max(py,y-hy),y+hy);
   zz = min(max(pz,z-hz),z+hz);
   d = (px-xx)^2 + (py-yy)^2 + (pz-zz)^2;
   if (pz > z) d = min(d,(max(sqrt((px-x)^2 + (py-y)^2)-.5,0))^2);
   return(d);
}

move_player (buf[PAKSIZ], play_t play[PLAYMAX], &playn, egg_t egg[EGGMAX], &eggn, steam_t steam[STEAMMAX], &steamn, plat_t plat[PLATMAX], &rseed, &gtim, dosound)
{
   p = buf[0]; dtim = buf[1]; mx = buf[2]; my = buf[3];

   play[p].h += mx*.01;
   play[p].v = min(max(play[p].v+my*.01*.75,PI*-.15),PI*.4);

   if (play[p].deathtim > 0)
   {
      play[p].deathtim -= dtim;
      if (play[p].deathtim <= 0) respawn(p,-1,play,&playn,plat,&rseed);
      return;
   }

   rx =-sin(play[p].h);
   ry = cos(play[p].h);
   rz = 0;
   fx = cos(play[p].h)*cos(play[p].v/.75);
   fy = sin(play[p].h)*cos(play[p].v/.75);
   fz =                sin(play[p].v/.75);
   dx = fy*rz - fz*ry;
   dy = fz*rx - fx*rz;
   dz = fx*ry - fy*rx;

   if (play[p].onfloor > 0)
   {
      x = ((buf[4]%4) >= 2) - ((buf[4]% 2) >= 1); //Right-Left
      z = ((buf[4]%8) >= 4) - ((buf[4]%16) >= 8); //Up-Down
      f = dtim*0.6;
      play[p].vx += (rx*x + fx*z)*f;
      play[p].vy += (ry*x + fy*z)*f;
   }
      //Flap
   if ((buf[4]%32) >= 16)
   {
      if ((p == net_me) && (dosound)) playsound("flap.flac",100,1,play[p].x,play[p].y,play[p].z);
      if (dosound) flaptim[p] = tim;
      f = 0.07;
      play[p].vx -= dx*f;
      play[p].vy -= dy*f;
      play[p].vz -= dz*f;
   }

   if ((buf[4]%64) >= 32) //Drop egg key :P
   {
      play[p].score--;
      spawnegg(p,p,play,&playn,egg,&eggn,&rseed);
   }

   play[p].vz += dtim*0.4; //Gravity
   if (play[p].z > -1) play[p].vz += dtim*(play[p].z+1)*.25; //Gravity higher near lava :P

   for(j=8-1;j>0;j--)
   {
      f = dtim*30;
      x = play[p].x+play[p].vx*f*(j%2);
      y = play[p].y+play[p].vy*f*((j%4) >= 2);
      z = play[p].z+play[p].vz*f*(j>=4);

         //Keep bird inside invisible hemisphere
      f = x^2 + y^2 + z^2;
      if (f > 96^2) { f = 96/sqrt(f); x *= f; y *= f; z *= f; }

      dmin = 1e32;
      for(i=platn-1;i>=0;i--)
      {
         d = dist2plat2(x,y,z,plat[i].x,plat[i].y,plat[i].z,plat[i].xs,plat[i].ys);
         if (d < dmin) dmin = d;
      }
      if (dmin < .3^2) continue;
      f = 1/(dtim*30);
      play[p].vx = (x-play[p].x)*f; play[p].x = x;
      play[p].vy = (y-play[p].y)*f; play[p].y = y;
      play[p].vz = (z-play[p].z)*f; play[p].z = z;
      break;
   }
   for(q=0;q<playn;q++)
   {
      if ((p == q) || (play[q].deathtim > 0)) continue;
      if ((play[p].x-play[q].x)^2 + (play[p].y-play[q].y)^2 + (play[p].z-play[q].z)^2 < 1.0^2)
      {
         if (fabs(play[p].z-play[q].z) < .25)
         {
            if ((play[p].vx-play[q].vx)*(play[p].x-play[q].x) +
                (play[p].vy-play[q].vy)*(play[p].y-play[q].y) < 0)
            {
               f = sqrt((play[q].x-play[p].x)^2 + (play[q].y-play[p].y)^2);
               if (f > .01)
               {
                  g = 1/f;
                  vx0 = play[p].vx; vy0 = play[p].vy; vx1 = play[q].vx; vy1 = play[q].vy;
                  f = doimpact(1,(play[q].x-play[p].x)*g,
                                 (play[q].y-play[p].y)*g,&vx0,&vy0,&vx1,&vy1);
                  play[p].vx = vx0; play[p].vy = vy0; play[q].vx = vx1; play[q].vy = vy1;
                  if (dosound) playsound("bounce.flac",f*100,2+f*1.5+(rnd-.5)*.05,play[p].x,play[p].y,play[p].z);
                  play[p].botgoal = q; play[q].botgoal = p;
               }
               else
               {
                  play[p].vx += (krnd(&rseed)-.5)*.1; play[p].vy += (krnd(&rseed)-.5)*.1;
                  play[q].vx += (krnd(&rseed)-.5)*.1; play[q].vy += (krnd(&rseed)-.5)*.1;
               }
            }
         }
         else
         {
            if (dosound) playsound("crow.flac",100,1.5,play[p].x,play[p].y,play[p].z);
            if (play[p].z > play[q].z)
            {
               spawnegg(p,q,play,&playn,egg,&eggn,&rseed);
               play[q].score++; play[p].score--; play[p].deathtim = 1;
               play[p].botgoal = q;
            }
         }
      }
   }

   if (j < 7)
   {
      if ((play[p].onfloor < 0) && (dosound)) playsound("plop.flac",100,1.5,play[p].x,play[p].y,play[p].z);
      play[p].onfloor = .25;
      f = .05;
      play[p].vx *= pow(f,dtim);
      play[p].vy *= pow(f,dtim);
   }
   else
   {
      play[p].onfloor -= dtim;
      f = .6;
      play[p].vx *= pow(f,dtim);
      play[p].vy *= pow(f,dtim);
      play[p].vz *= pow(f,dtim);
   }
   if (play[p].z >= .5)
   {
      steam[steamn].x = play[p].x;
      steam[steamn].y = play[p].y;
      steam[steamn].owner = p;
      steam[steamn].tim = 0;
      steamn++;

      if (dosound) playsound("sizzle.flac",50,0.6,play[p].x,play[p].y,play[p].z);
      play[p].deathtim = 1;
      play[p].score--;
   }
}

move_objects (dtim, play_t play[PLAYMAX], &playn, egg_t egg[EGGMAX], &eggn, steam_t steam[STEAMMAX], &steamn, plat_t plat[PLATMAX], &rseed, &gtim, dosound)
{
   gtim += dtim;
   plat[movingplat].x = cos(gtim*.1)*MOVINGRAD;
   plat[movingplat].y = sin(gtim*.1)*MOVINGRAD;
   plat[movingplat].z = -3;
   plat[movingplat].xs = 2;
   plat[movingplat].ys = 2;

   for(e=eggn-1;e>=0;e--)
   {
      egg[e].vz += dtim*0.4; //Gravity

      for(j=8-1;j>0;j--)
      {
         f = dtim*30;
         x = egg[e].x+egg[e].vx*f*(j%2);
         y = egg[e].y+egg[e].vy*f*((j%4) >= 2);
         z = egg[e].z+egg[e].vz*f*(j>=4);

            //Keep egg inside invisible hemisphere
         f = x^2 + y^2 + z^2;
         if (f > 96^2) { f = 96/sqrt(f); x *= f; y *= f; z *= f; }

         dmin = 1e32;
         for(i=platn-1;i>=0;i--)
         {
            d = dist2plat2(x,y,z,plat[i].x,plat[i].y,plat[i].z,plat[i].xs,plat[i].ys);
            if (d < dmin) dmin = d;
         }
         if (dmin < .20^2) continue;
         f = 1/(dtim*30);
         egg[e].vx = (x-egg[e].x)*f; egg[e].x = x;
         egg[e].vy = (y-egg[e].y)*f; egg[e].y = y;
         egg[e].vz = (z-egg[e].z)*f; egg[e].z = z;
         break;
      }

      if (j < 7)
      {
         if (egg[e].onfloor == 0)
         {
            egg[e].onfloor += dtim;
            if (dosound) playsound("plop.flac",100,1.5,egg[e].x,egg[e].y,egg[e].z);
         }
         f = .005;
         egg[e].vx *= pow(f,dtim);
         egg[e].vy *= pow(f,dtim);

         if (dist2plat2(egg[e].x,egg[e].y,egg[e].z,plat[movingplat].x,plat[movingplat].y,plat[movingplat].z,
                        plat[movingplat].xs,plat[movingplat].ys) < .4^2)
         {
            egg[e].x += (cos(gtim*.1)-cos((gtim-dtim)*.1))*MOVINGRAD;
            egg[e].y += (sin(gtim*.1)-sin((gtim-dtim)*.1))*MOVINGRAD;
         }
      }
      else
      {
         if (egg[e].onfloor >= .25) egg[e].onfloor = 0;
         f = .6;
         egg[e].vx *= pow(f,dtim);
         egg[e].vy *= pow(f,dtim);
         egg[e].vz *= pow(f,dtim);
      }

      if (egg[e].z > .5)
      {
         steam[steamn].x = egg[e].x;
         steam[steamn].y = egg[e].y;
         steam[steamn].owner = egg[e].owner;
         steam[steamn].tim = 0;
         steamn++;

         if (dosound) playsound("sizzle.flac",50,1.0,egg[e].x,egg[e].y,egg[e].z);
         eggn--; egg[e] = egg[eggn];
         continue;
      }

      for(q=playn-1;q>=0;q--)
      {
         if ((egg[e].owner == q) && (play[q].deathtim > 0)) continue;
         d = (egg[e].x-play[q].x)^2 + (egg[e].y-play[q].y)^2 + (egg[e].z-play[q].z)^2;
         if (d < 0.7^2)
         {
            //if (egg[e].owner != q)
            play[q].score++;
            if (dosound) playsound("plop.flac",100,.5,egg[e].x,egg[e].y,egg[e].z);
            eggn--; egg[e] = egg[eggn];
            break;
         }
      }
   }

   for(q=playn-1;q>=0;q--)
   {
      if (dist2plat2(play[q].x,play[q].y,play[q].z,plat[movingplat].x,
            plat[movingplat].y,plat[movingplat].z,
            plat[movingplat].xs,plat[movingplat].ys) < .4^2)
      {
         play[q].x += (cos(gtim*.1)-cos((gtim-dtim)*.1))*MOVINGRAD;
         play[q].y += (sin(gtim*.1)-sin((gtim-dtim)*.1))*MOVINGRAD;
      }
   }

   for(s=steamn-1;s>=0;s--)
   {
      steam[s].x -= dtim*1.6;
      steam[s].y -= dtim*1.6;
      steam[s].tim += dtim; if (steam[s].tim < 3) continue;
      steamn--; steam[s] = steam[steamn];
   }

   for(i=net_players;i<playn;i++)
   {
      static npak[PAKSIZ];
      bot_ai(i,npak,dtim,play,&playn,egg,&eggn,&rseed);
      move_player(npak,play,&playn,egg,&eggn,steam,&steamn,plat,&rseed,&gtim,dosound);
   }
}

   //e            Coefficient of restitution: 0=plastic, 1=elastic
   //nx,ny        Unit normal vector at intersection
   //&vx,&vy      Velocity
doimpact (e,nx,ny,&ivx,&ivy,&jvx,&jvy)
{
   dvx = ivx - jvx;
   dvy = ivy - jvy;
   f = (dvx*nx + dvy*ny) * (-e-1.0) / 2;
   ivx += nx*f; jvx -= nx*f;
   ivy += ny*f; jvy -= ny*f;
   return(f);
}

bot_ai (p, lpak[PAKSIZ], dtim, play_t play[PLAYMAX], &playn, egg_t egg[EGGMAX], &eggn, &rseed)
{
   if ((krnd(&rseed) < dtim*.1) || ((play[p].botgoal < playn) && (play[play[p].botgoal].deathtim > 0)) || (play[p].botgoal-1e6 >= eggn))
   {
      dmin = 1e32;
      for(zx=4;zx>0;zx--)
      {
         g = int((playn+eggn-1)*krnd(&rseed));
         if (g >= p) g++;
         if (g >= playn) g += 1e6-playn;
         if (g < playn) { gx = play[g    ].x; gy = play[g    ].y; }
                   else { gx =  egg[g-1e6].x; gy =  egg[g-1e6].y; }
         d = (gx-play[p].x)^2 + (gy-play[p].y)^2;
         if (d < dmin) { dmin = d; bg = g; }
      }
      play[p].botgoal = bg;
   }
   if (play[p].botgoal < playn)
   {
      gx = play[play[p].botgoal].x; gvx = play[play[p].botgoal].vx;
      gy = play[play[p].botgoal].y; gvy = play[play[p].botgoal].vy;
      gz = play[play[p].botgoal].z; gvz = play[play[p].botgoal].vz;
   }
   else
   {
      gx = egg[play[p].botgoal-1e6].x; gvx = egg[play[p].botgoal-1e6].vx;
      gy = egg[play[p].botgoal-1e6].y; gvy = egg[play[p].botgoal-1e6].vy;
      gz = egg[play[p].botgoal-1e6].z; gvz = egg[play[p].botgoal-1e6].vz;
   }
   lpak[0] = p;
   lpak[1] = dtim;
   if (AI_STUCK) { lpak[2] = 0; lpak[3] = 0; lpak[4] = 0; return; } //static bird!
   f = 1;
   dx = (gx+gvx*f   )-(play[p].x+play[p].vx*f);
   dy = (gy+gvy*f   )-(play[p].y+play[p].vy*f);
   dz = (gz+gvz*f-.2)-(play[p].z+play[p].vz*f);
   a = atan2(dy,dx);
   lpak[2] = ((a-play[p].h+PI)%(PI*2)-PI)*7;
   lpak[3] = 0;
   lpak[4] = 4;
   if (lpak[2] < .1) lpak[4] += 1;
   if (lpak[2] > .1) lpak[4] += 2;

   d = 0;
   if (dz < 0) d -= dtim*max(dz,-2)*12/max(sqrt(sqrt(dx^2+dy^2)),1);
   if ((play[p].z > -3) && ((fabs(play[p].x) > 8) || (fabs(play[p].y) > 8))) d += dtim*6;
   if (play[p].z+play[p].vz > -1) d += dtim*8;
   if (play[p].z > -1) d += dtim*8;
   if (krnd(&rseed) < d) lpak[4] += 16;
}

getcrc (lpak[PAKSIZ], play_t play[PLAYMAX], &playn, egg_t egg[EGGMAX], &eggn, steam_t steam[STEAMMAX], &steamn, &rseed, &gtim)
{
   for(i=0;i<PAKSIZ;i++) lpak[i] = 0;

   lpak[1] += steamn*2;
   for(i=0;i<steamn;i++)
   {
      lpak[1] += steam[i].x*-3;
      lpak[1] += steam[i].y*+5;
      lpak[1] += steam[i].owner*-7;
      lpak[1] += steam[i].tim*+9;
   }

   lpak[1] += playn*-7;
   for(i=0;i<playn;i++)
   {
      lpak[2] += play[i].x*+11;
      lpak[2] += play[i].y*-13;
      lpak[2] += play[i].z*+17;
      lpak[3] += play[i].vx*-19;
      lpak[3] += play[i].vy*+23;
      lpak[3] += play[i].vz*-29;
      lpak[4] += play[i].h*+31;
      lpak[4] += play[i].v*-37;
      lpak[1] += play[i].onfloor*+41;
      lpak[1] += play[i].deathtim*-43;
      lpak[1] += play[i].score*+47;
   }

   lpak[1] += eggn*-53;
   for(i=0;i<eggn;i++)
   {
      lpak[1] += egg[i].x*+59;
      lpak[1] += egg[i].y*-61;
      lpak[1] += egg[i].z*+67;
      lpak[1] += egg[i].vx*-71;
      lpak[1] += egg[i].vy*+73;
      lpak[1] += egg[i].vz*-79;
      lpak[1] += egg[i].onfloor*+83;
      lpak[1] += egg[i].owner*-89;
   }

   lpak[1] += rseed*+91;
   lpak[1] += gtim*-97;
}

writecrc (from,lpak[PAKSIZ])
{
   for(i=0;i<PAKSIZ;i++) crcv[from][crcn[from]][i] = lpak[i];
   crcn[from]++;
   for(i=net_players-1;i>=0;i--) if (crcn[i] < crcn[from]) break;
   if ((i < 0) && (oos == 0))
      for(p=net_players-1;p>0;p--)
         for(i=1;i<PAKSIZ;i++)
            if (crcv[0][crcn[from]-1][i] != crcv[p][crcn[from]-1][i])
               { playtext(",Out of sync!"); oos = i; }
}

//-------------------------------------------------------------------------------------------------

drawskybox ()
{
   setcol(0xa06060); glsettex("kensky.jpg");

   glbegin(GL_QUADS); f = 256; g = .5/384;
   gltexcoord(  g,(0+g)/6); glvertex(-f,-f,-f);
   gltexcoord(1-g,(0+g)/6); glvertex(+f,-f,-f);
   gltexcoord(1-g,(1-g)/6); glvertex(+f,-f,+f);
   gltexcoord(  g,(1-g)/6); glvertex(-f,-f,+f);

   gltexcoord(  g,(1+g)/6); glvertex(+f,-f,-f);
   gltexcoord(1-g,(1+g)/6); glvertex(+f,+f,-f);
   gltexcoord(1-g,(2-g)/6); glvertex(+f,+f,+f);
   gltexcoord(  g,(2-g)/6); glvertex(+f,-f,+f);

   gltexcoord(  g,(2+g)/6); glvertex(+f,+f,-f);
   gltexcoord(1-g,(2+g)/6); glvertex(-f,+f,-f);
   gltexcoord(1-g,(3-g)/6); glvertex(-f,+f,+f);
   gltexcoord(  g,(3-g)/6); glvertex(+f,+f,+f);

   gltexcoord(  g,(3+g)/6); glvertex(-f,+f,-f);
   gltexcoord(1-g,(3+g)/6); glvertex(-f,-f,-f);
   gltexcoord(1-g,(4-g)/6); glvertex(-f,-f,+f);
   gltexcoord(  g,(4-g)/6); glvertex(-f,+f,+f);

   gltexcoord(  g,(4+g)/6); glvertex(-f,+f,-f);
   gltexcoord(1-g,(4+g)/6); glvertex(+f,+f,-f);
   gltexcoord(1-g,(5-g)/6); glvertex(+f,-f,-f);
   gltexcoord(  g,(5-g)/6); glvertex(-f,-f,-f);

      //No need to draw floor; lava covers it
   //gltexcoord(  g,(5+g)/6); glvertex(-f,-f,+f);
   //gltexcoord(1-g,(5+g)/6); glvertex(+f,-f,+f);
   //gltexcoord(1-g,(6-g)/6); glvertex(+f,+f,+f);
   //gltexcoord(  g,(6-g)/6); glvertex(-f,+f,+f);
}

drawplat (x,y,z,hx,hy)
{
   if (hx >= hy) { u = hx/hy; v = 1; }
            else { u = 1; v = hy/hx; }
   hz = .2;
   glsettex("purpmont.jpg"); u *= 1.5; v *= 1.5;
   glbegin(GL_QUADS);
   gltexcoord(0,0); glvertex(x-hx,y-hy,z-hz);
   gltexcoord(u,0); glvertex(x+hx,y-hy,z-hz);
   gltexcoord(u,v); glvertex(x+hx,y+hy,z-hz);
   gltexcoord(0,v); glvertex(x-hx,y+hy,z-hz);
   setcol(0x707070);
   gltexcoord(0,0); glvertex(x-hx,y+hy,z+hz);
   gltexcoord(u,0); glvertex(x+hx,y+hy,z+hz);
   gltexcoord(u,v); glvertex(x+hx,y-hy,z+hz);
   gltexcoord(0,v); glvertex(x-hx,y-hy,z+hz);
   glend();

   if (0)
   {
      setcol(0x504020);
      drawcone(x-hx,y-hy,z,hz,x+hx,y-hy,z,hz,DRAWCONE_NOCAP0);
      drawcone(x+hx,y-hy,z,hz,x+hx,y+hy,z,hz,DRAWCONE_NOCAP0);
      drawcone(x+hx,y+hy,z,hz,x-hx,y+hy,z,hz,DRAWCONE_NOCAP0);
      drawcone(x-hx,y+hy,z,hz,x-hx,y-hy,z,hz,DRAWCONE_NOCAP0);
      drawcone(x,y,z-hz,-.2,x,y,0,-.5,DRAWCONE_NOCAP+DRAWCONE_CENT);
   }
   else
   {
      glbegin(GL_QUADS); setcol(0xa08040);
      gltexcoord( 0, 0); glvertex(x-hx,y+hy,z-hz);
      gltexcoord(hx, 0); glvertex(x+hx,y+hy,z-hz);
      gltexcoord(hx,hz); glvertex(x+hx,y+hy,z+hz);
      gltexcoord( 0,hz); glvertex(x-hx,y+hy,z+hz);

      gltexcoord( 0, 0); glvertex(x+hx,y+hy,z-hz);
      gltexcoord(hy, 0); glvertex(x+hx,y-hy,z-hz);
      gltexcoord(hy,hz); glvertex(x+hx,y-hy,z+hz);
      gltexcoord( 0,hz); glvertex(x+hx,y+hy,z+hz);

      gltexcoord( 0, 0); glvertex(x+hx,y-hy,z-hz);
      gltexcoord(hx, 0); glvertex(x-hx,y-hy,z-hz);
      gltexcoord(hx,hz); glvertex(x-hx,y-hy,z+hz);
      gltexcoord( 0,hz); glvertex(x+hx,y-hy,z+hz);

      gltexcoord( 0, 0); glvertex(x-hx,y-hy,z-hz);
      gltexcoord(hy, 0); glvertex(x-hx,y+hy,z-hz);
      gltexcoord(hy,hz); glvertex(x-hx,y+hy,z+hz);
      gltexcoord( 0,hz); glvertex(x-hx,y-hy,z+hz);

      n = 6;
      for(i=0;i<n;i++)
      {
         glbegin(GL_QUADS); setcol(0xa08040);
         c0 = cos( i   *PI*2/n);
         s0 = sin( i   *PI*2/n);
         c1 = cos((i+1)*PI*2/n);
         s1 = sin((i+1)*PI*2/n);
         gltexcoord( i   /n,0); glvertex(x+c0*.4,y+s0*.4,0);
         gltexcoord((i+1)/n,0); glvertex(x+c1*.4,y+s1*.4,0);
         gltexcoord((i+1)/n,2); glvertex(x+c1*.2,y+s1*.2,z+hz);
         gltexcoord( i   /n,2); glvertex(x+c0*.2,y+s0*.2,z+hz);
      }
   }
}

   //Rotate vectors a & b around their common plane, by ang
rotate_vecs (ang,a[3],b[3])
{
   c = cos(ang); s = sin(ang);
   for(i=3-1;i>=0;i--) { f = a[i]; a[i] = f*c + b[i]*s; b[i] = b[i]*c - f*s; }
}

drawbird (x,y,z,hang,vang,tang,plat_t plat[PLATMAX])
{
   static point3d r, d, f;

   for(s=0;s<2;s++)
   for(i=-2;i<=2;i++)
   {
      nx = x;
      ny = y;
      nz = z;
      r.x =-sin(hang); f.x = cos(hang)*cos(vang);
      r.y = cos(hang); f.y = sin(hang)*cos(vang);
      r.z = 0;         f.z =           sin(vang);
      d.x = f.y*r.z - f.z*r.y;
      d.y = f.z*r.x - f.x*r.z;
      d.z = f.x*r.y - f.y*r.x;

      rotate_vecs(tang*i,r,d);
      if (abs(i) == 2)
      {
         nz += tang*-.40;
                  g = abs(sin(tang))*.02;
         nx += r.x*g*i;
         ny += r.y*g*i;
         nz += r.z*g*i;
      }
      if (s)
      {
         setcol(0); r.z = 0; d.z = 0; f.z = 0;
         nz = -0.1;
         for(j=platn-1;j>=0;j--)
            if ((fabs(nx-plat[j].x) < plat[j].xs) &&
                (fabs(ny-plat[j].y) < plat[j].ys) &&
                (plat[j].z < nz) && (plat[j].z > z)) nz = plat[j].z-.25;
      }

      if (i == 0) {
      g = .80; drawspr( "torso.kv6",nx,ny,nz,r.x* g,r.y* g,r.z* g,
                                             d.x* g,d.y* g,d.z* g,
                                             f.x* g,f.y* g,f.z* g); }
      if (i == -1) {
      g = .18; drawspr("wingl1.kv6",nx,ny,nz,r.x* g,r.y* g,r.z* g,
                                             d.x* g,d.y* g,d.z* g,
                                             f.x* g,f.y* g,f.z* g); }
      if (i == -2) {
      g = .30; drawspr("wingl2.kv6",nx,ny,nz,r.x* g,r.y* g,r.z* g,
                                             d.x* g,d.y* g,d.z* g,
                                             f.x* g,f.y* g,f.z* g); }
      if (i == 1) {
      g = .18; drawspr("wingl1.kv6",nx,ny,nz,r.x*-g,r.y*-g,r.z*-g,
                                             d.x* g,d.y* g,d.z* g,
                                             f.x* g,f.y* g,f.z* g); }
      if (i == 2) {
      g = .30; drawspr("wingl2.kv6",nx,ny,nz,r.x*-g,r.y*-g,r.z*-g,
                                             d.x* g,d.y* g,d.z* g,
                                             f.x* g,f.y* g,f.z* g); }
   }
}

drawit (myview, play_t play[PLAYMAX], &playn, egg_t egg[EGGMAX], &eggn, steam_t steam[STEAMMAX], &steamn, plat_t plat[PLATMAX])
{

   //clz(1e32);

   p = myview;
   rx =-sin(play[p].h);
   ry = cos(play[p].h);
   rz = 0;
   fx = cos(play[p].h)*cos(play[p].v);
   fy = sin(play[p].h)*cos(play[p].v);
   fz =                sin(play[p].v);
   dx = fy*rz - fz*ry;
   dy = fz*rx - fx*rz;
   dz = fx*ry - fy*rx;

   sterdir = sgn(numframes%2-.5)*(USINGSTEREO!=0);
   setview(0,0,xres,yres,xres/2+pixoff*sterdir,yres/2,xres/2);

   gldisable(GL_DEPTH_TEST);
   setcam(0,0,0,rx,ry,rz,dx,dy,dz,fx,fy,fz);
   drawskybox();

   d = 4; f = sepoff*sterdir;
   setcam(play[p].x-fx*d+rx*f,play[p].y-fy*d+ry*f,min(play[p].z-fz*d,-1.3)+rz*f,
          rx,ry,rz,dx,dy,dz,fx,fy,fz);

   glsettex("lava2.jpg"); setcol(0x707070);
   glbegin(GL_COMPLEX);
   f = 128; n = 32; t = (tim*.1)%1;
   for(i=0;i<n;i++)
   {
      c = cos(i*PI*2/n); s = sin(i*PI*2/n);
      gltexcoord(c*f/16+t,s*f/16+t);
      glvertex(c*f,s*f,0);
   }
   glend();
   glenable(GL_DEPTH_TEST);

   for(i=0;i<platn;i++)
   {
      setcol(plat[i].c);
      drawplat(plat[i].x,plat[i].y,plat[i].z,plat[i].xs,plat[i].ys);
   }

   for(i=steamn-1;i>=0;i--)
   {
      c = playcol[steam[i].owner];
      setcol((c/65536)*.8,(int(c/256)%256)*.8,(c%256)*.8);
      for(j=256;j>0;j--)
      {
         z = (j*3.16+steam[i].tim)%1;
         r = (j*.34)%.3;
         x = cos(j*(sqrt(5)-1)*PI)*r;
         y = sin(j*(sqrt(5)-1)*PI)*r;
         if (steam[i].tim < z) continue;
         r = (1.1-z)*.03;
         if (steam[i].tim > 2) r *= (3-steam[i].tim);
         drawsph(steam[i].x+x,steam[i].y+y,-z,r);
      }
   }

   for(i=eggn-1;i>=0;i--)
   {
      setcol(playcol[egg[i].owner]);
      drawspr("egg.kv6",egg[i].x,egg[i].y,egg[i].z,.23,0,PI/2);
   }

   for(i=playn-1;i>=0;i--)
   {
      if (play[i].deathtim > 0) continue;
      f = 0; if (tim-flaptim[i] < .25) f = sin((tim-flaptim[i])*PI*2/.25)*.5;
      setcol(playcol[i]);
      drawbird(play[i].x,play[i].y,play[i].z,play[i].h,play[i].v,f,plat);
   }

   i = net_me;
   setcol(0x40c0c0); drawcone(xres-88,i*20+6,10,xres,i*20+6,10);
   setcol(0x206060); drawcone(xres-88,i*20+6, 9,xres,i*20+6, 9);
   if (myview != net_me)
   {
      i = myview;
      setcol(int(sin(tim*8)*64+96)*0x010100);
      drawcone(xres-88,i*20+6,8,xres,i*20+6,8);
   }
   for(i=playn-1;i>=0;i--)
   {
      setcol(playcol[i]);
      setfont(12,18,1); moveto(xres-88,i*20); printf("%g:%5g",i+1,play[i].score);
   }

   if (tim < 3)
   {
      i = 255-tim*32;
      setcol(i,i,i);
      setfont(24,36,1);
      moveto(xres/2-200,60);
      printf("Turn: Mouse\n");
      printf("Flap: Ctrl/Shift/MBut\n");
      printf("Walk: Arrows\n");
   }

   if (p != net_me)
   {
      setcol(playcol[p]);
      setfont(24,36,1);
      moveto(xres/2-200,0);
      printf("Viewing player %g",p+1);
   }

   if (oos) { setfont(xres/4,yres*.6,0); setcol(0xff0000); moveto(0,yres*.25); printf("OOS%g",oos); }
}
//-------------------------------------------------------------------------------------------------
